"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
class MemoryCache {
    constructor(itemsExpirationCheckIntervalInSecs, maxItemCount) {
        this.itemsExpirationCheckIntervalInSecs = itemsExpirationCheckIntervalInSecs;
        this.maxItemCount = maxItemCount;
        this.itemKeyToItemValueWrapperMap = new Map();
        this.itemCount = 0;
        this.deleteExpiredItems = () => {
            const currentTimestampInMillisSinceEpoch = Date.now();
            const iterator = this.itemKeyToItemValueWrapperMap.entries();
            this.deleteExpiredItemsFromBatch(iterator, currentTimestampInMillisSinceEpoch);
        };
        this.timer = setInterval(this.deleteExpiredItems, itemsExpirationCheckIntervalInSecs * 1000);
    }
    storePermanentItem(itemKey, itemValue) {
        this.storeExpiringItem(itemKey, itemValue, 0);
    }
    storeExpiringItem(itemKey, itemValue, timeToLiveInSecs) {
        if (this.timer === null) {
            throw new Error('Cache is destroyed. Cannot store items anymore.');
        }
        if (this.itemCount < this.maxItemCount) {
            this.itemKeyToItemValueWrapperMap.set(itemKey, {
                itemValue,
                expirationTimestampInMillisSinceEpoch: timeToLiveInSecs
                    ? Date.now() + timeToLiveInSecs * 1000
                    : undefined,
            });
            this.itemCount++;
        }
    }
    getItemCount() {
        return this.itemCount;
    }
    hasItem(itemKey) {
        return this.itemKeyToItemValueWrapperMap.has(itemKey);
    }
    retrieveItemValue(itemKey) {
        var _a;
        return (_a = this.itemKeyToItemValueWrapperMap.get(itemKey)) === null || _a === void 0 ? void 0 : _a.itemValue;
    }
    getItemExpirationTimestampInMillisSinceEpoch(itemKey) {
        var _a;
        return (_a = this.itemKeyToItemValueWrapperMap.get(itemKey)) === null || _a === void 0 ? void 0 : _a.expirationTimestampInMillisSinceEpoch;
    }
    removeItem(itemKey) {
        if (this.hasItem(itemKey)) {
            this.itemKeyToItemValueWrapperMap.delete(itemKey);
            this.itemCount--;
        }
    }
    clear() {
        this.itemKeyToItemValueWrapperMap.clear();
        this.itemCount = 0;
    }
    destroy() {
        if (this.timer) {
            this.clear();
            clearInterval(this.timer);
            this.timer = null;
        }
    }
    deleteExpiredItemsFromBatch(iterator, currentTimestampInMillisSinceEpoch) {
        for (let i = 0; i < MemoryCache.EXPIRATION_PROCESSING_ITEM_BATCH_SIZE; i++) {
            const iteratorResult = iterator.next();
            if (iteratorResult.done) {
                return;
            }
            const [itemKey, valueWrapper] = iteratorResult.value;
            if (valueWrapper.expirationTimestampInMillisSinceEpoch &&
                valueWrapper.expirationTimestampInMillisSinceEpoch < currentTimestampInMillisSinceEpoch) {
                this.itemKeyToItemValueWrapperMap.delete(itemKey);
                this.itemCount--;
            }
        }
        setImmediate(() => this.deleteExpiredItemsFromBatch(iterator, currentTimestampInMillisSinceEpoch));
    }
}
exports.default = MemoryCache;
MemoryCache.EXPIRATION_PROCESSING_ITEM_BATCH_SIZE = 100000;
//# sourceMappingURL=MemoryCache.js.map